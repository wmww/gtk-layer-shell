/* AUTOGENERATED, DO NOT EDIT DIRECTLY
 * See gtk-priv/README.md for more information
 *
 * This file is part of gtk-layer-shell
 *
 * Copyright (C) 2019 Red Hat, Inc.
 * Copyright Â© 2021 gtk-priv/scripts/code.py
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#ifndef GDK_SURFACE_CLASS_PRIV_H
#define GDK_SURFACE_CLASS_PRIV_H

#include "common.h"

typedef struct _GdkSurfaceClass GdkSurfaceClass;

// Version ID 0
// Valid for GTK master
struct _GdkSurfaceClass_v3_0_0
{
  GObjectClass parent_class;
  cairo_surface_t * (* ref_cairo_surface) (GdkSurface *surface);
  void (* hide) (GdkSurface *surface);
  void (* get_geometry) (GdkSurface *surface, int *x, int *y, int *width, int *height);
  void (* get_root_coords) (GdkSurface *surface, int x, int y, int *root_x, int *root_y);
  gboolean (* get_device_state) (GdkSurface *surface, GdkDevice *device, double *x, double *y, GdkModifierType *mask);
  void (* set_input_region) (GdkSurface *surface, cairo_region_t *shape_region);
  void (* destroy) (GdkSurface *surface, gboolean foreign_destroy);
  gboolean (* beep) (GdkSurface *surface);
  void (* destroy_notify) (GdkSurface *surface);
  GdkDrag * (* drag_begin) (GdkSurface *surface, GdkDevice *device, GdkContentProvider *content, GdkDragAction actions, double dx, double dy);
  int (* get_scale_factor) (GdkSurface *surface);
  void (* get_unscaled_size) (GdkSurface *surface, int *unscaled_width, int *unscaled_height);
  void (* set_opaque_region) (GdkSurface *surface, cairo_region_t *region);
  GdkGLContext * (* create_gl_context) (GdkSurface *surface, gboolean attached, GdkGLContext *share, GError **error);
  void (* request_layout) (GdkSurface *surface);
  gboolean (* compute_size) (GdkSurface *surface);
};

// For internal use only
int gdk_surface_class_priv_get_version_id() {
  static int version_id = -1;
  
  if (version_id == -1) {
    gtk_priv_assert_gtk_version_valid();
    int combo = gtk_get_minor_version() * 1000 + gtk_get_micro_version();
  
    switch (combo) {
        break;
  
      default:
        gtk_priv_warn_gtk_version_may_be_unsupported();
    }
  
    {
      version_id = 0;
    }
  }
  
  return version_id;
}

// GdkSurfaceClass::parent_class

GObjectClass * gdk_surface_class_priv_get_parent_class_ptr(GdkSurfaceClass * self) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: return (GObjectClass *)&((struct _GdkSurfaceClass_v3_0_0*)self)->parent_class;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurfaceClass::ref_cairo_surface

cairo_surface_t * (* gdk_surface_class_priv_get_ref_cairo_surface(GdkSurfaceClass * self)) (GdkSurface *surface) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: return ((struct _GdkSurfaceClass_v3_0_0*)self)->ref_cairo_surface;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_class_priv_set_ref_cairo_surface(GdkSurfaceClass * self, cairo_surface_t * (* ref_cairo_surface) (GdkSurface *surface)) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: ((struct _GdkSurfaceClass_v3_0_0*)self)->ref_cairo_surface = ref_cairo_surface; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurfaceClass::hide

void (* gdk_surface_class_priv_get_hide(GdkSurfaceClass * self)) (GdkSurface *surface) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: return ((struct _GdkSurfaceClass_v3_0_0*)self)->hide;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_class_priv_set_hide(GdkSurfaceClass * self, void (* hide) (GdkSurface *surface)) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: ((struct _GdkSurfaceClass_v3_0_0*)self)->hide = hide; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurfaceClass::get_geometry

void (* gdk_surface_class_priv_get_get_geometry(GdkSurfaceClass * self)) (GdkSurface *surface, int *x, int *y, int *width, int *height) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: return ((struct _GdkSurfaceClass_v3_0_0*)self)->get_geometry;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_class_priv_set_get_geometry(GdkSurfaceClass * self, void (* get_geometry) (GdkSurface *surface, int *x, int *y, int *width, int *height)) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: ((struct _GdkSurfaceClass_v3_0_0*)self)->get_geometry = get_geometry; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurfaceClass::get_root_coords

void (* gdk_surface_class_priv_get_get_root_coords(GdkSurfaceClass * self)) (GdkSurface *surface, int x, int y, int *root_x, int *root_y) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: return ((struct _GdkSurfaceClass_v3_0_0*)self)->get_root_coords;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_class_priv_set_get_root_coords(GdkSurfaceClass * self, void (* get_root_coords) (GdkSurface *surface, int x, int y, int *root_x, int *root_y)) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: ((struct _GdkSurfaceClass_v3_0_0*)self)->get_root_coords = get_root_coords; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurfaceClass::get_device_state

gboolean (* gdk_surface_class_priv_get_get_device_state(GdkSurfaceClass * self)) (GdkSurface *surface, GdkDevice *device, double *x, double *y, GdkModifierType *mask) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: return ((struct _GdkSurfaceClass_v3_0_0*)self)->get_device_state;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_class_priv_set_get_device_state(GdkSurfaceClass * self, gboolean (* get_device_state) (GdkSurface *surface, GdkDevice *device, double *x, double *y, GdkModifierType *mask)) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: ((struct _GdkSurfaceClass_v3_0_0*)self)->get_device_state = get_device_state; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurfaceClass::set_input_region

void (* gdk_surface_class_priv_get_set_input_region(GdkSurfaceClass * self)) (GdkSurface *surface, cairo_region_t *shape_region) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: return ((struct _GdkSurfaceClass_v3_0_0*)self)->set_input_region;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_class_priv_set_set_input_region(GdkSurfaceClass * self, void (* set_input_region) (GdkSurface *surface, cairo_region_t *shape_region)) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: ((struct _GdkSurfaceClass_v3_0_0*)self)->set_input_region = set_input_region; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurfaceClass::destroy

void (* gdk_surface_class_priv_get_destroy(GdkSurfaceClass * self)) (GdkSurface *surface, gboolean foreign_destroy) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: return ((struct _GdkSurfaceClass_v3_0_0*)self)->destroy;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_class_priv_set_destroy(GdkSurfaceClass * self, void (* destroy) (GdkSurface *surface, gboolean foreign_destroy)) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: ((struct _GdkSurfaceClass_v3_0_0*)self)->destroy = destroy; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurfaceClass::beep

gboolean (* gdk_surface_class_priv_get_beep(GdkSurfaceClass * self)) (GdkSurface *surface) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: return ((struct _GdkSurfaceClass_v3_0_0*)self)->beep;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_class_priv_set_beep(GdkSurfaceClass * self, gboolean (* beep) (GdkSurface *surface)) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: ((struct _GdkSurfaceClass_v3_0_0*)self)->beep = beep; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurfaceClass::destroy_notify

void (* gdk_surface_class_priv_get_destroy_notify(GdkSurfaceClass * self)) (GdkSurface *surface) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: return ((struct _GdkSurfaceClass_v3_0_0*)self)->destroy_notify;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_class_priv_set_destroy_notify(GdkSurfaceClass * self, void (* destroy_notify) (GdkSurface *surface)) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: ((struct _GdkSurfaceClass_v3_0_0*)self)->destroy_notify = destroy_notify; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurfaceClass::drag_begin

GdkDrag * (* gdk_surface_class_priv_get_drag_begin(GdkSurfaceClass * self)) (GdkSurface *surface, GdkDevice *device, GdkContentProvider *content, GdkDragAction actions, double dx, double dy) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: return ((struct _GdkSurfaceClass_v3_0_0*)self)->drag_begin;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_class_priv_set_drag_begin(GdkSurfaceClass * self, GdkDrag * (* drag_begin) (GdkSurface *surface, GdkDevice *device, GdkContentProvider *content, GdkDragAction actions, double dx, double dy)) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: ((struct _GdkSurfaceClass_v3_0_0*)self)->drag_begin = drag_begin; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurfaceClass::get_scale_factor

int (* gdk_surface_class_priv_get_get_scale_factor(GdkSurfaceClass * self)) (GdkSurface *surface) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: return ((struct _GdkSurfaceClass_v3_0_0*)self)->get_scale_factor;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_class_priv_set_get_scale_factor(GdkSurfaceClass * self, int (* get_scale_factor) (GdkSurface *surface)) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: ((struct _GdkSurfaceClass_v3_0_0*)self)->get_scale_factor = get_scale_factor; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurfaceClass::get_unscaled_size

void (* gdk_surface_class_priv_get_get_unscaled_size(GdkSurfaceClass * self)) (GdkSurface *surface, int *unscaled_width, int *unscaled_height) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: return ((struct _GdkSurfaceClass_v3_0_0*)self)->get_unscaled_size;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_class_priv_set_get_unscaled_size(GdkSurfaceClass * self, void (* get_unscaled_size) (GdkSurface *surface, int *unscaled_width, int *unscaled_height)) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: ((struct _GdkSurfaceClass_v3_0_0*)self)->get_unscaled_size = get_unscaled_size; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurfaceClass::set_opaque_region

void (* gdk_surface_class_priv_get_set_opaque_region(GdkSurfaceClass * self)) (GdkSurface *surface, cairo_region_t *region) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: return ((struct _GdkSurfaceClass_v3_0_0*)self)->set_opaque_region;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_class_priv_set_set_opaque_region(GdkSurfaceClass * self, void (* set_opaque_region) (GdkSurface *surface, cairo_region_t *region)) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: ((struct _GdkSurfaceClass_v3_0_0*)self)->set_opaque_region = set_opaque_region; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurfaceClass::create_gl_context

GdkGLContext * (* gdk_surface_class_priv_get_create_gl_context(GdkSurfaceClass * self)) (GdkSurface *surface, gboolean attached, GdkGLContext *share, GError **error) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: return ((struct _GdkSurfaceClass_v3_0_0*)self)->create_gl_context;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_class_priv_set_create_gl_context(GdkSurfaceClass * self, GdkGLContext * (* create_gl_context) (GdkSurface *surface, gboolean attached, GdkGLContext *share, GError **error)) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: ((struct _GdkSurfaceClass_v3_0_0*)self)->create_gl_context = create_gl_context; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurfaceClass::request_layout

void (* gdk_surface_class_priv_get_request_layout(GdkSurfaceClass * self)) (GdkSurface *surface) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: return ((struct _GdkSurfaceClass_v3_0_0*)self)->request_layout;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_class_priv_set_request_layout(GdkSurfaceClass * self, void (* request_layout) (GdkSurface *surface)) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: ((struct _GdkSurfaceClass_v3_0_0*)self)->request_layout = request_layout; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

// GdkSurfaceClass::compute_size

gboolean (* gdk_surface_class_priv_get_compute_size(GdkSurfaceClass * self)) (GdkSurface *surface) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: return ((struct _GdkSurfaceClass_v3_0_0*)self)->compute_size;
    default: g_error("Invalid version ID"); g_abort();
  }
}

void gdk_surface_class_priv_set_compute_size(GdkSurfaceClass * self, gboolean (* compute_size) (GdkSurface *surface)) {
  switch (gdk_surface_class_priv_get_version_id()) {
    case 0: ((struct _GdkSurfaceClass_v3_0_0*)self)->compute_size = compute_size; break;
    default: g_error("Invalid version ID"); g_abort();
  }
}

#endif // GDK_SURFACE_CLASS_PRIV_H
